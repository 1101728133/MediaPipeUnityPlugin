diff --git a/mediapipe/util/BUILD b/mediapipe/util/BUILD
index 9347fc0..a346675 100644
--- a/mediapipe/util/BUILD
+++ b/mediapipe/util/BUILD
@@ -149,7 +149,7 @@ cc_library(
 cc_library(
     name = "resource_util",
     srcs = select({
-        "//conditions:default": ["resource_util.cc"],
+        "//conditions:default": ["resource_util_unity.cc"],
         "//mediapipe:android": ["resource_util_android.cc"],
         "//mediapipe:ios": ["resource_util_apple.cc"],
         "//mediapipe:macos": ["resource_util.cc"],
@@ -164,7 +164,7 @@ cc_library(
         "//mediapipe:macos": [],
     }),
     visibility = [
-        "//mediapipe/framework:mediapipe_internal",
+        "//visibility:public",
     ],
     deps = [
         "//mediapipe/framework/port:ret_check",
diff --git a/mediapipe/util/resource_util.h b/mediapipe/util/resource_util.h
index d55706a..b7d9b39 100644
--- a/mediapipe/util/resource_util.h
+++ b/mediapipe/util/resource_util.h
@@ -22,6 +22,9 @@
 
 namespace mediapipe {
 
+const char* GetResourceRootPath();
+void SetResourceRootPath(const std::string& path);
+
 // Given a path to a resource, this function attempts to provide an absolute
 // path with which it can be accessed as a file.
 // - If the input path is an absolute path, it is returned as-is.
diff --git a/mediapipe/util/resource_util_unity.cc b/mediapipe/util/resource_util_unity.cc
new file mode 100644
index 0000000..f9523fe
--- /dev/null
+++ b/mediapipe/util/resource_util_unity.cc
@@ -0,0 +1,93 @@
+// Copyright 2019 The MediaPipe Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// `PathToResourceAsFile` is based on mediapipe/util/resource_util_android.cc and
+// `GetResourceContents' is copied from mediapipe/util/resource_util.cc
+
+#include "mediapipe/util/resource_util.h"
+
+#include "absl/flags/flag.h"
+#include "absl/strings/str_split.h"
+#include "mediapipe/framework/deps/file_path.h"
+#include "mediapipe/framework/port/file_helpers.h"
+#include "mediapipe/framework/port/ret_check.h"
+
+namespace mediapipe {
+
+namespace {
+const char* resourceRootPath;
+
+::mediapipe::StatusOr<std::string> PathToResourceAsFileInternal(const std::string& path) {
+  RET_CHECK_OK(mediapipe::file::Exists(path));
+
+  return path;
+}
+}
+
+const char* GetResourceRootPath() {
+  if (resourceRootPath == nullptr) {
+    return "";
+  }
+
+  return resourceRootPath;
+}
+
+void SetResourceRootPath(const std::string& path) {
+  auto str_ptr = new char[path.length() + 1];
+  snprintf(str_ptr, path.length() + 1, path.c_str());
+
+  if (resourceRootPath != nullptr) {
+    delete[] resourceRootPath;
+  }
+
+  resourceRootPath = str_ptr;
+}
+
+::mediapipe::StatusOr<std::string> PathToResourceAsFile(
+    const std::string& path) {
+
+  if (absl::StartsWith(path, "/")) {
+    return path;
+  }
+
+  LOG(INFO) << "Path: " << path;
+
+  // Try to load a relative path
+  {
+    auto resource_path = mediapipe::file::JoinPath(GetResourceRootPath(), path);
+    auto status_or_path = PathToResourceAsFileInternal(resource_path);
+    if (status_or_path.ok()) {
+      LOG(INFO) << "Successfully loaded: " << path;
+      return status_or_path;
+    }
+  }
+
+  // If that fails, assume it was a relative path, and try just the base name.
+  {
+    const size_t last_slash_idx = path.find_last_of("\\/");
+    CHECK_NE(last_slash_idx, std::string::npos);  // Make sure it's a path.
+    auto base_name = path.substr(last_slash_idx + 1);
+    auto asset_path = mediapipe::file::JoinPath(GetResourceRootPath(), base_name);
+    auto status_or_path = PathToResourceAsFileInternal(asset_path);
+    if (status_or_path.ok()) LOG(INFO) << "Successfully loaded: " << asset_path;
+    return status_or_path;
+  }
+}
+
+::mediapipe::Status GetResourceContents(const std::string& path,
+                                        std::string* output) {
+  return mediapipe::file::GetContents(path, output);
+}
+
+}  // namespace mediapipe
